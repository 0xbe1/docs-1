---
title: ユニットテストフレームワーク
---

Matchstick は[LimeChain](https://limechain.tech/)が開発したユニットテストフレームワークで、サブグラフの開発者がサンドボックス環境でマッピングロジックをテストし、自信を持ってサブグラフをデプロイすることができます!

[Matchstick installation guide](https://github.com/LimeChain/matchstick/blob/main/README.md#quick-start-)に従ってインストールしてください。これで、最初のユニットテストの作成に移ることができます。

## ユニットテストを書く

Gravatar の[Example Subgraph](https://github.com/graphprotocol/example-subgraph)を使って、簡単なユニットテストを書いてみましょう。

以下のようなハンドラー関数があるとします（より簡易化するための 2 つのヘルパー関数も一緒に）。

```javascript
export function handleNewGravatar(event: NewGravatar): void {
  let gravatar = new Gravatar(event.params.id.toHex())
  gravatar.owner = event.params.owner
  gravatar.displayName = event.params.displayName
  gravatar.imageUrl = event.params.imageUrl
  gravatar.save()
}

export function handleNewGravatars(events: NewGravatar[]): void {
  events.forEach((event) => {
    handleNewGravatar(event)
  })
}

export function createNewGravatarEvent(
  id: i32,
  ownerAddress: string,
  displayName: string,
  imageUrl: string
): NewGravatar {
  let mockEvent = newMockEvent()
  let newGravatarEvent = new NewGravatar(
    mockEvent.address,
    mockEvent.logIndex,
    mockEvent.transactionLogIndex,
    mockEvent.logType,
    mockEvent.block,
    mockEvent.transaction,
    mockEvent.parameters
  )
  newGravatarEvent.parameters = new Array()
  let idParam = new ethereum.EventParam('id', ethereum.Value.fromI32(id))
  let addressParam = new ethereum.EventParam(
    'ownderAddress',
    ethereum.Value.fromAddress(Address.fromString(ownerAddress))
  )
  let displayNameParam = new ethereum.EventParam('displayName', ethereum.Value.fromString(displayName))
  let imageUrlParam = new ethereum.EventParam('imageUrl', ethereum.Value.fromString(imageUrl))

  newGravatarEvent.parameters.push(idParam)
  newGravatarEvent.parameters.push(addressParam)
  newGravatarEvent.parameters.push(displayNameParam)
  newGravatarEvent.parameters.push(imageUrlParam)

  return newGravatarEvent
}
```

まず、プロジェクト内にテストファイルを作成する必要があります。以下がそのような例です：

```typescript
import { clearStore, test, assert } from 'matchstick-as/assembly/index'
import { Gravatar } from '../../generated/schema'
import { NewGravatar } from '../../generated/Gravity/Gravity'
import { createNewGravatarEvent, handleNewGravatars } from '../mappings/gravity'

test('Can call mappings with custom events', () => {
  // Create a test entity and save it in the store as initial state (optional)
  let gravatar = new Gravatar('gravatarId0')
  gravatar.save()

  // Create mock events
  let newGravatarEvent = createNewGravatarEvent(12345, '0x89205A3A3b2A69De6Dbf7f01ED13B2108B2c43e7', 'cap', 'pac')
  let anotherGravatarEvent = createNewGravatarEvent(3546, '0x89205A3A3b2A69De6Dbf7f01ED13B2108B2c43e7', 'cap', 'pac')

  // Call mapping functions passing the events we just created
  handleNewGravatars([newGravatarEvent, anotherGravatarEvent])

  // Assert the state of the store
  assert.fieldEquals('Gravatar', 'gravatarId0', 'id', 'gravatarId0')
  assert.fieldEquals('Gravatar', '12345', 'owner', '0x89205A3A3b2A69De6Dbf7f01ED13B2108B2c43e7')
  assert.fieldEquals('Gravatar', '3546', 'displayName', 'cap')

  // Clear the store in order to start the next test off on a clean slate
  clearStore()
})

test('Next test', () => {
  //...
})

```

まず重要なのは、`matchstick-as`という AssemblyScript のヘルパーライブラリ(npm モジュールとして配布)からインポートしていることです。リポジトリは[ここ](https://github.com/LimeChain/matchstick-as)にあります。`matchstick-as` は便利なテストメソッドを提供してくれますし、テストブロックを構築するのに使う`test()`関数も定義しています。残りの部分はとても簡単で、以下のようになります:

- 初期状態を設定し、カスタム Gravatar エンティティを 1 つ追加しています。
- `createNewGravatarEvent()`関数を使って、2 つの`NewGravatar`イベントオブジェクトとそのデータを定義しています。
- これらのイベントのハンドラ・メソッド`handleNewGravatars()`を呼び出し、カスタム・イベントのリストを渡しています。
- ストアの状態をアサートしています。これはどのような仕組みなのでしょうか？- Entity タイプと id のユニークな組み合わせを渡しています。そして、その Entity の特定のフィールドをチェックして、期待する値を持っていることをアサートします。これは、ストアに追加した最初の Gravatar Entity と、ハンドラ関数が呼び出されたときに追加される 2 つの Gravatar Entity の両方に対して行っています。
- 最後に、`clearStore()`を使ってストアを掃除し、次のテストが新鮮で空のストア・オブジェクトで始められるようにしています。テストブロックは必要に応じていくつでも定義できます。

これで最初のテストが完成しました! 👏

テストを実行するには、サブグラフのルートフォルダで以下を実行する必要があります：

`gravityのテスト`

すべてがうまくいくと、以下のメッセージが表示されます：

![Matchstick saying “All tests passed!”](/img/matchstick-tests-passed.png)

## 一般的なテストシナリオ

### 特定の状態でストアにハイドレーティングする

ユーザーは、既知のエンティティのセットでストアをハイドレートすることができます。ここでは、Gravatarのエンティティでストアを初期化する例を示します：

```typescript
let gravatar = new Gravatar('entryId')
gravatar.save()
```

### イベントを使ったマッピング関数の呼び出し

ユーザーはカスタムイベントを作成し、それをストアにバインドされたマッピング関数に渡すことができます：

```typescript
import { store } from 'matchstick-as/assembly/store'
import { NewGravatar } from '../../generated/Gravity/Gravity'
import { handleNewGravatars, createNewGravatarEvent } from './mapping'

let newGravatarEvent = createNewGravatarEvent(12345, '0x89205A3A3b2A69De6Dbf7f01ED13B2108B2c43e7', 'cap', 'pac')

handleNewGravatar(newGravatarEvent)
```

### イベントフィクスチャですべてのマッピングを呼び出す

ユーザーはテストフィクスチャでマッピングを呼び出すことができます。

```typescript
import { NewGravatar } from '../../generated/Gravity/Gravity'
import { store } from 'matchstick-as/assembly/store'
import { handleNewGravatars, createNewGravatarEvent } from './mapping'

let newGravatarEvent = createNewGravatarEvent(12345, '0x89205A3A3b2A69De6Dbf7f01ED13B2108B2c43e7', 'cap', 'pac')

let anotherGravatarEvent = createNewGravatarEvent(3546, '0x89205A3A3b2A69De6Dbf7f01ED13B2108B2c43e7', 'cap', 'pac')

handleNewGravatars([newGravatarEvent, anotherGravatarEvent])
```

```
export function handleNewGravatars(events: NewGravatar[]): void {
    events.forEach(event => {
        handleNewGravatar(event);
    });
}
```

### コントラクトコールのモック

ユーザーはコントラクトコールをモックすることができます：

```typescript
import { addMetadata, assert, createMockedFunction, clearStore, test } from 'matchstick-as/assembly/index'
import { Gravity } from '../../generated/Gravity/Gravity'
import { Address, BigInt, ethereum } from '@graphprotocol/graph-ts'

let contractAddress = Address.fromString('0x89205A3A3b2A69De6Dbf7f01ED13B2108B2c43e7')
let expectedResult = Address.fromString('0x90cBa2Bbb19ecc291A12066Fd8329D65FA1f1947')
let bigIntParam = BigInt.fromString('1234')
createMockedFunction(contractAddress, 'gravatarToOwner', 'gravatarToOwner(uint256):(address)')
  .withArgs([ethereum.Value.fromSignedBigInt(bigIntParam)])
  .returns([ethereum.Value.fromAddress(Address.fromString('0x90cBa2Bbb19ecc291A12066Fd8329D65FA1f1947'))])

let gravity = Gravity.bind(contractAddress)
let result = gravity.gravatarToOwner(bigIntParam)

assert.equals(ethereum.Value.fromAddress(expectedResult), ethereum.Value.fromAddress(result))
```

このように、コントラクトの呼び出しと戻り値をハードコア化するために、ユーザーはコントラクトのアドレス、関数名、関数シグネチャ、引数の配列、そしてもちろん戻り値を提供する必要があります。

また、関数の戻り値をモックすることもできます：

```typescript
let contractAddress = Address.fromString('0x89205A3A3b2A69De6Dbf7f01ED13B2108B2c43e7')
createMockedFunction(contractAddress, 'getGravatar', 'getGravatar(address):(string,string)')
  .withArgs([ethereum.Value.fromAddress(contractAddress)])
  .reverts()
```

### ストアの状態をアサートする

ユーザーは、エンティティをアサートすることで、ストアの最終的な状態（または途中の状態）をアサートすることができます。これを実行するためには、ユーザーはエンティティタイプ、エンティティの特定の ID、フィールド名、フィールドの期待値を指定する必要があります。以下に例を示します：

```typescript
import { assert } from 'matchstick-as/assembly/index'
import { Gravatar } from '../generated/schema'

let gravatar = new Gravatar('gravatarId0')
gravatar.save()

assert.fieldEquals('Gravatar', 'gravatarId0', 'id', 'gravatarId0')
```

Assert.fieldEquals()関数を実行すると、指定されたフィールドが指定された期待値と等しいかどうかをチェックします。値が**等しくない** 場合は、テストは失敗し、エラーメッセージが出力されます。それ以外の場合は、テストは正常に通過します。

### イベントメタデータとのやりとり

ユーザーは、`newMockEvent()`関数を使用して ethereum.Eventとして返されるデフォルトのトランザクションのメタデータを使用することができます。以下の例では、イベントオブジェクトのこれらのフィールドを読み書きする方法を示しています：

```typescript
// Read
let logType = newGravatarEvent.logType

// Write
let UPDATED_ADDRESS = '0xB16081F360e3847006dB660bae1c6d1b2e17eC2A'
newGravatarEvent.address = Address.fromString(UPDATED_ADDRESS)
```

### 変数の等値性の主張

```typescript
assert.equals(ethereum.Value.fromString("hello"); ethereum.Value.fromString("hello"));
```

### エンティティがストアに**ない**ことをアサートする

ユーザーは、あるエンティティがストアに存在しないことをアサートできます。この関数は、エンティティタイプと id を受け取ります。エンティティが実際にストア内にある場合、テストは関連するエラーメッセージを表示して失敗します。この機能を使った簡単な例をご紹介します：

```typescript
assert.notInStore('Gravatar', '23')
```

### ストア全体を印刷する（デバッグ用）

このヘルパー関数を使って、ストア全体をコンソールに出力することができます：

```typescript
import { logStore } from "matchstick-as/assembly/store";

logStore();
```

### 予想される不具合

Test() 関数のshouldFailフラグを使用して、ユーザーがテストの失敗を予想することができます：

```typescript
test("Should throw an error", () => {
  throw new Error();
}, true);
```

ShouldFail = true とマークされているにもかかわらずテストが失敗した場合は、ログにエラーとして表示され、テストブロックは失敗します。また、shouldFail = false (デフォルトの状態) と設定されている場合は、テスト実行者がクラッシュします。

### ロギング

ユニットテストにカスタムログを持たせることは、マッピングにログを持たせることと全く同じです。違いは、ログオブジェクトをgraph-tsではなくmatchstick-asからインポートする必要があることです。以下は、すべての非重要なログタイプを使った簡単な例です：

```typescript
import { test } from "matchstick-as/assembly/index";
import { log } from "matchstick-as/assembly/log";

test("Success", () => {
    log.success("Success!". []);
});
test("Error", () => {
    log.error("Error :( ", []);
});
test("Debug", () => {
    log.debug("Debugging...", []);
});
test("Info", () => {
    log.info("Info!", []);
});
test("Warning", () => {
    log.warning("Warning!", []);
});
```

ユーザーは、このように致命的な失敗をシミュレートすることもできます：

```typescript
test("Blow everything up", () => {
    log.critical("Boom!");
});
```

クリティカルエラーのログを取るとテストの実行が止まり、すべてが飛んでしまいます。コードに重要なログがデプロイされていないことを確認し、もし発生した場合にはすぐに気付く必要があります。

### 派生フィールドのテスト

派生フィールドのテストは、（以下の例で示すように）ユーザーがあるエンティティにフィールドを設定し、それが最初のエンティティからフィールドの1つを派生している場合、別のエンティティが自動的に更新されるようにする機能です。重要なのは、自動更新はASコードが不可知論である錆のストア内で行われるため、最初のエンティティは再ロードされる必要があることです。

```typescript
test("Derived fields example test", () => {
    let mainAccount = new GraphAccount("12")
    mainAccount.save()
    let operatedAccount = new GraphAccount("1")
    operatedAccount.operators = ["12"]
    operatedAccount.save()
    let nst = new NameSignalTransaction("1234")
    nst.signer = "12";
    nst.save()

    assert.assertNull(mainAccount.get("nameSignalTransactions"))
    assert.assertNull(mainAccount.get("operatorOf"))

    mainAccount = GraphAccount.load("12")!

    assert.i32Equals(1, mainAccount.nameSignalTransactions.length)
    assert.stringEquals("1", mainAccount.operatorOf[0])
})
```

### 動的データソースのテスト

動的データソースのテストは、dataSource namespaceの context(), address(), network() 関数の戻り値をモックすることで行うことができます。context - 空のエンティティ (DataSourceContext) を返し、address - "0x0000000000000000000000" を返し、network - "mainnet" を返します。create(...) と createWithContext(...) 関数は何もしないようにモック化されているので、テストの中で呼び出す必要は全くありません。戻り値の変更は matchstick-as (version 0.3.0+) の dataSourceMock namespaceの関数で行うことができます。以下はその例です：まず、次のようなイベントハンドラがあります (これは、データソースのモックを紹介するために意図的に再利用されています)：

```typescript
export function handleApproveTokenDestinations(event: ApproveTokenDestinations): void {
  let tokenLockWallet = TokenLockWallet.load(dataSource.address().toHexString())!
  if (dataSource.network() == "rinkeby") {
    tokenLockWallet.tokenDestinationsApproved = true
  }
  let context = dataSource.context()
  if (context.get("contextVal")!.toI32() > 0) {
    tokenLockWallet.setBigInt("tokensReleased", BigInt.fromI32(context.get("contextVal")!.toI32()))
  }
  tokenLockWallet.save()
}
```

そして、dataSourceMock namespaceのメソッドの1つを使用して、すべてのdataSource関数に新しい戻り値を設定するテストがあります：

```typescript
import { assert, test, newMockEvent, dataSourceMock } from "matchstick-as/assembly/index"
import { BigInt, DataSourceContext, Value } from "@graphprotocol/graph-ts"

import { handleApproveTokenDestinations } from "../../src/token-lock-wallet"
import { ApproveTokenDestinations } from "../../generated/templates/GraphTokenLockWallet/GraphTokenLockWallet"
import { TokenLockWallet } from "../../generated/schema"

test("Data source simple mocking example", () => {
    let addressString = "0xA16081F360e3847006dB660bae1c6d1b2e17eC2A"
    let address = Address.fromString(addressString)

    let wallet = new TokenLockWallet(address.toHexString())
    wallet.save()
    let context = new DataSourceContext()
    context.set("contextVal", Value.fromI32(325))
    dataSourceMock.setReturnValues(addressString, "rinkeby", context)
    let event = changetype<ApproveTokenDestinations>(newMockEvent())

    assert.assertTrue(!wallet.tokenDestinationsApproved)

    handleApproveTokenDestinations(event)

    wallet = TokenLockWallet.load(address.toHexString())!
    assert.assertTrue(wallet.tokenDestinationsApproved)
    assert.bigIntEquals(wallet.tokensReleased, BigInt.fromI32(325))

    dataSourceMock.resetValues()
})
```

最後にdataSourceMock.resetValues()が呼び出されていることに注目してください。これは、値が変更されると記憶されるため、デフォルトの値に戻したい場合はリセットする必要があるからです。

### ログ出力でのテスト実行時間の表示

ログ出力にテスト実行時間が含まれるようになりました。以下はその例です：

`Jul 09 14:54:42.420 INFO Program execution time: 10.06022ms`

## フィードバック

質問、フィードバックなどがありましたら、The Graph DiscordにMatchstick専用のチャンネル🔥| unit-testing がありますので、そちらにお問い合わせください。
