---
title: Marco de Unit Testing
---

Matchstick es un marco de unit testing, desarrollado por [LimeChain](https://limechain.tech/), que permite a los desarrolladores de subgrafos probar su l√≥gica de mapeo en un entorno sandbox y desplegar sus subgrafos con confianza!

Sigue la [Matchstick installation guide](https://github.com/LimeChain/matchstick/blob/main/README.md#quick-start-) para instalar. Ahora, puede pasar a escribir tu primera unit test.

## Escribe una Unit Test

Veamos c√≥mo ser√≠a una unit test sencilla, utilizando el Gravatar [Example Subgraph](https://github.com/graphprotocol/example-subgraph).

Suponiendo que tenemos la siguiente funci√≥n handler (junto con dos funciones de ayuda para facilitarnos la vida):

```javascript
export function handleNewGravatar(event: NewGravatar): void {
  let gravatar = new Gravatar(event.params.id.toHex())
  gravatar.owner = event.params.owner
  gravatar.displayName = event.params.displayName
  gravatar.imageUrl = event.params.imageUrl
  gravatar.save()
}

export function handleNewGravatars(events: NewGravatar[]): void {
  events.forEach((event) => {
    handleNewGravatar(event)
  })
}

export function createNewGravatarEvent(
  id: i32,
  ownerAddress: string,
  displayName: string,
  imageUrl: string
): NewGravatar {
  let mockEvent = newMockEvent()
  let newGravatarEvent = new NewGravatar(
    mockEvent.address,
    mockEvent.logIndex,
    mockEvent.transactionLogIndex,
    mockEvent.logType,
    mockEvent.block,
    mockEvent.transaction,
    mockEvent.parameters
  )
  newGravatarEvent.parameters = new Array()
  let idParam = new ethereum.EventParam('id', ethereum.Value.fromI32(id))
  let addressParam = new ethereum.EventParam(
    'ownderAddress',
    ethereum.Value.fromAddress(Address.fromString(ownerAddress))
  )
  let displayNameParam = new ethereum.EventParam('displayName', ethereum.Value.fromString(displayName))
  let imageUrlParam = new ethereum.EventParam('imageUrl', ethereum.Value.fromString(imageUrl))

  newGravatarEvent.parameters.push(idParam)
  newGravatarEvent.parameters.push(addressParam)
  newGravatarEvent.parameters.push(displayNameParam)
  newGravatarEvent.parameters.push(imageUrlParam)

  return newGravatarEvent
}
```

Primero tenemos que crear un archivo de prueba en nuestro proyecto. Este es un ejemplo de c√≥mo podr√≠a ser:

```typescript
import { clearStore, test, assert } from 'matchstick-as/assembly/index'
import { Gravatar } from '../../generated/schema'
import { NewGravatar } from '../../generated/Gravity/Gravity'
import { createNewGravatarEvent, handleNewGravatars } from '../mappings/gravity'

test('Can call mappings with custom events', () => {
  // Create a test entity and save it in the store as initial state (optional)
  let gravatar = new Gravatar('gravatarId0')
  gravatar.save()

  // Create mock events
  let newGravatarEvent = createNewGravatarEvent(12345, '0x89205A3A3b2A69De6Dbf7f01ED13B2108B2c43e7', 'cap', 'pac')
  let anotherGravatarEvent = createNewGravatarEvent(3546, '0x89205A3A3b2A69De6Dbf7f01ED13B2108B2c43e7', 'cap', 'pac')

  // Call mapping functions passing the events we just created
  handleNewGravatars([newGravatarEvent, anotherGravatarEvent])

  // Assert the state of the store
  assert.fieldEquals('Gravatar', 'gravatarId0', 'id', 'gravatarId0')
  assert.fieldEquals('Gravatar', '12345', 'owner', '0x89205A3A3b2A69De6Dbf7f01ED13B2108B2c43e7')
  assert.fieldEquals('Gravatar', '3546', 'displayName', 'cap')

  // Clear the store in order to start the next test off on a clean slate
  clearStore()
})

test('Next test', () => {
  //...
})

```

¬°Es mucho para desempacar! En primer lugar, una cosa importante a notar es que estamos importando cosas de `matchstick-as`, nuestra biblioteca de ayuda de AssemblyScript (distribuida como un m√≥dulo npm). Puedes encontrar el repositorio [aqu√≠](https://github.com/LimeChain/matchstick-as). `matchstick-as` nos proporciona √∫tiles m√©todos de prueba y tambi√©n define la funci√≥n `test()` que utilizaremos para construir nuestros bloques de prueba. El resto es bastante sencillo: esto es lo que ocurre:

- Estamos configurando nuestro estado inicial y a√±adiendo una entidad Gravatar personalizada;
- Definimos dos objetos de evento `NewGravatar` junto con sus datos, utilizando la funci√≥n `createNewGravatarEvent()`;
- Estamos llamando a los m√©todos handlers de esos eventos - `handleNewGravatars()` y pasando la lista de nuestros eventos personalizados;
- Hacemos valer el estado del almac√©n. ¬øC√≥mo funciona eso? - Pasamos una combinaci√≥n √∫nica de tipo de Entidad e id. A continuaci√≥n, comprobamos un campo espec√≠fico de esa Entidad y afirmamos que tiene el valor que esperamos que tenga. Hacemos esto tanto para la Entidad Gravatar inicial que a√±adimos al almac√©n, como para las dos entidades Gravatar que se a√±aden cuando se llama a la funci√≥n del handler;
- Y por √∫ltimo - estamos limpiando el almac√©n usando `clearStore()` para que nuestra pr√≥xima prueba pueda comenzar con un objeto almac√©n fresco y vac√≠o. Podemos definir tantos bloques de prueba como queramos.

Ya est√°: ¬°hemos creado nuestra primera prueba! üëè

Ahora, para ejecutar nuestras pruebas, s√≥lo tienes que ejecutar lo siguiente en la carpeta ra√≠z de tu subgrafo:

`graph test Gravity`

Y si todo va bien deber√≠as ser recibido con lo siguiente:

![Matchstick dice "¬°Todas las pruebas superadas!"](/img/matchstick-tests-passed.png)

## Escenarios de prueba comunes

### Hidratar la tienda con un cierto estado

Los usuarios pueden hidratar la tienda con un conjunto conocido de entidades. Aqu√≠ hay un ejemplo para inicializar la tienda con una entidad Gravatar:

```typescript
let gravatar = new Gravatar('entryId')
gravatar.save()
```

### Llamada a una funci√≥n de mapeo con un evento

Un usuario puede crear un evento personalizado y pasarlo a una funci√≥n de mapeo que est√° vinculada a la tienda:

```typescript
import { store } from 'matchstick-as/assembly/store'
import { NewGravatar } from '../../generated/Gravity/Gravity'
import { handleNewGravatars, createNewGravatarEvent } from './mapping'

let newGravatarEvent = createNewGravatarEvent(12345, '0x89205A3A3b2A69De6Dbf7f01ED13B2108B2c43e7', 'cap', 'pac')

handleNewGravatar(newGravatarEvent)
```

### Llamar a todos los mapeos con fixtures de eventos

Los usuarios pueden llamar a los mapeos con accesorios de prueba.

```typescript
import { NewGravatar } from '../../generated/Gravity/Gravity'
import { store } from 'matchstick-as/assembly/store'
import { handleNewGravatars, createNewGravatarEvent } from './mapping'

let newGravatarEvent = createNewGravatarEvent(12345, '0x89205A3A3b2A69De6Dbf7f01ED13B2108B2c43e7', 'cap', 'pac')

let anotherGravatarEvent = createNewGravatarEvent(3546, '0x89205A3A3b2A69De6Dbf7f01ED13B2108B2c43e7', 'cap', 'pac')

handleNewGravatars([newGravatarEvent, anotherGravatarEvent])
```

```
export function handleNewGravatars(events: NewGravatar[]): void {
    events.forEach(event => {
        handleNewGravatar(event);
    });
}
```

### Simular llamadas de contratos

Los usuarios pueden simular las llamadas de los contratos:

```typescript
import { addMetadata, assert, createMockedFunction, clearStore, test } from 'matchstick-as/assembly/index'
import { Gravity } from '../../generated/Gravity/Gravity'
import { Address, BigInt, ethereum } from '@graphprotocol/graph-ts'

let contractAddress = Address.fromString('0x89205A3A3b2A69De6Dbf7f01ED13B2108B2c43e7')
let expectedResult = Address.fromString('0x90cBa2Bbb19ecc291A12066Fd8329D65FA1f1947')
let bigIntParam = BigInt.fromString('1234')
createMockedFunction(contractAddress, 'gravatarToOwner', 'gravatarToOwner(uint256):(address)')
  .withArgs([ethereum.Value.fromSignedBigInt(bigIntParam)])
  .returns([ethereum.Value.fromAddress(Address.fromString('0x90cBa2Bbb19ecc291A12066Fd8329D65FA1f1947'))])

let gravity = Gravity.bind(contractAddress)
let result = gravity.gravatarToOwner(bigIntParam)

assert.equals(ethereum.Value.fromAddress(expectedResult), ethereum.Value.fromAddress(result))
```

Como se ha demostrado, para burlarse de una llamada a un contrato y endurecer un valor de retorno, el usuario debe proporcionar una direcci√≥n de contrato, el nombre de la funci√≥n, la firma de la funci√≥n, un array de argumentos y, por supuesto, el valor de retorno.

Los usuarios tambi√©n pueden burlarse de las reversiones de funciones:

```typescript
let contractAddress = Address.fromString('0x89205A3A3b2A69De6Dbf7f01ED13B2108B2c43e7')
createMockedFunction(contractAddress, 'getGravatar', 'getGravatar(address):(string,string)')
  .withArgs([ethereum.Value.fromAddress(contractAddress)])
  .reverts()
```

### Afirmar el estado del almac√©n

Los usuarios pueden afirmar el estado final (o intermedio) del almac√©n mediante la afirmaci√≥n de entidades. Para hacer esto, el usuario tiene que suministrar un tipo de entidad, el ID espec√≠fico de una entidad, un nombre de un campo en esa entidad, y el valor esperado del campo. He aqu√≠ un ejemplo r√°pido:

```typescript
import { assert } from 'matchstick-as/assembly/index'
import { Gravatar } from '../generated/schema'

let gravatar = new Gravatar('gravatarId0')
gravatar.save()

assert.fieldEquals('Gravatar', 'gravatarId0', 'id', 'gravatarId0')
```

Al ejecutar la funci√≥n assert.fieldEquals() se comprobar√° la igualdad del campo dado contra el valor esperado dado. La prueba fallar√° y se emitir√° un mensaje de error si los valores **NOT** son iguales. De otra forma, la prueba pasar√° satisfactoriamente.

### Interacci√≥n con los metadatos de los Eventos

Los usuarios pueden utilizar los metadatos de la transacci√≥n por defecto, que podr√≠an ser devueltos como un ethereum.Event utilizando la funci√≥n `newMockEvent()`. El siguiente ejemplo muestra c√≥mo se puede leer/escribir en esos campos del objeto Event:

```typescript
// Read
let logType = newGravatarEvent.logType

// Write
let UPDATED_ADDRESS = '0xB16081F360e3847006dB660bae1c6d1b2e17eC2A'
newGravatarEvent.address = Address.fromString(UPDATED_ADDRESS)
```

### Afirmar la igualdad de las variables

```typescript
assert.equals(ethereum.Value.fromString("hello"); ethereum.Value.fromString("hello"));
```

### Afirmar que una Entidad es **no** en el almac√©n

Los usuarios pueden afirmar que una entidad no existe en el almac√©n. La funci√≥n toma un tipo de entidad y un id. Si la entidad est√° de hecho en el almac√©n, la prueba fallar√° con un mensaje de error relevante. Aqu√≠ hay un ejemplo r√°pido de c√≥mo utilizar esta funcionalidad:

```typescript
assert.notInStore('Gravatar', '23')
```

### Impresi√≥n de todo el almac√©n (con fines de depuraci√≥n)

Puedes imprimir todo el almac√©n en la consola utilizando esta funci√≥n de ayuda:

```typescript
import { logStore } from "matchstick-as/assembly/store";

logStore();
```

### Falla Esperada

Los usuarios pueden tener fallos esperados en las pruebas, utilizando la bandera shouldFail en las funciones test():

```typescript
test("Should throw an error", () => {
  throw new Error();
}, true);
```

Si la prueba est√° marcada con shouldFail = true pero NO falla, eso aparecer√° como un error en los registros y el bloque de prueba fallar√°. Adem√°s, si se marca con shouldFail = false (el estado por defecto), el ejecutor de la prueba se bloquear√°.

### Registro

Tener registros personalizados en las pruebas unitarias es exactamente lo mismo que el registro en los mapeos. La diferencia es que el objeto log necesita ser importado desde matchstick-as en lugar de graph-ts. Aqu√≠ hay un ejemplo sencillo con todos los tipos de registro no cr√≠ticos:

```typescript
import { test } from "matchstick-as/assembly/index";
import { log } from "matchstick-as/assembly/log";

test("Success", () => {
    log.success("Success!". []);
});
test("Error", () => {
    log.error("Error :( ", []);
});
test("Debug", () => {
    log.debug("Debugging...", []);
});
test("Info", () => {
    log.info("Info!", []);
});
test("Warning", () => {
    log.warning("Warning!", []);
});
```

Los usuarios tambi√©n pueden simular un fallo cr√≠tico, as√≠:

```typescript
test("Blow everything up", () => {
    log.critical("Boom!");
});
```

El registro de los errores cr√≠ticos detendr√° la ejecuci√≥n de las pruebas y har√° que todo se estropee. Despu√©s de todo - queremos asegurarnos de que tu c√≥digo no tiene registros cr√≠ticos en el despliegue, y debe anotar de inmediato si eso fuera a suceder.

### Comprobaci√≥n de los campos derivados

Probar los campos derivados es una caracter√≠stica que (como muestra el ejemplo siguiente) permite al usuario establecer un campo en una determinada entidad y hacer que otra entidad se actualice autom√°ticamente si deriva uno de sus campos de la primera entidad. Algo importante a tener en cuenta es que la primera entidad necesita ser recargada ya que la actualizaci√≥n autom√°tica se produce en el almac√©n en el que el c√≥digo AS es agn√≥stico.

```typescript
test("Derived fields example test", () => {
    let mainAccount = new GraphAccount("12")
    mainAccount.save()
    let operatedAccount = new GraphAccount("1")
    operatedAccount.operators = ["12"]
    operatedAccount.save()
    let nst = new NameSignalTransaction("1234")
    nst.signer = "12";
    nst.save()

    assert.assertNull(mainAccount.get("nameSignalTransactions"))
    assert.assertNull(mainAccount.get("operatorOf"))

    mainAccount = GraphAccount.load("12")!

    assert.i32Equals(1, mainAccount.nameSignalTransactions.length)
    assert.stringEquals("1", mainAccount.operatorOf[0])
})
```

### Prueba de fuentes de datos din√°micas

La prueba de las fuentes de datos din√°micas puede realizarse imitando el valor de retorno de las funciones context(), address() y network() del espacio de nombres dataSource. Estas funciones actualmente devuelven lo siguiente: context - returns an empty entity (DataSourceContext), address - returns "0x00000000000000000000000000000000", network - returns "mainnet". Las funciones create(...) y createWithContext(...) se simulan para no hacer nada, por lo que no es necesario llamarlas en las pruebas. Los cambios en los valores de retorno pueden hacerse a trav√©s de las funciones del espacio de nombres dataSourceMock en matchstick-as (versi√≥n 0.3.0+). Ejemplo siguiente: En primer lugar tenemos el siguiente handler de eventos (que ha sido reutilizado intencionadamente para mostrar el mock de datasource):

```typescript
export function handleApproveTokenDestinations(event: ApproveTokenDestinations): void {
  let tokenLockWallet = TokenLockWallet.load(dataSource.address().toHexString())!
  if (dataSource.network() == "rinkeby") {
    tokenLockWallet.tokenDestinationsApproved = true
  }
  let context = dataSource.context()
  if (context.get("contextVal")!.toI32() > 0) {
    tokenLockWallet.setBigInt("tokensReleased", BigInt.fromI32(context.get("contextVal")!.toI32()))
  }
  tokenLockWallet.save()
}
```

Y luego tenemos la prueba utilizando uno de los m√©todos en el espacio de nombres dataSourceMock para establecer un nuevo valor de retorno para todas las funciones dataSource:

```typescript
import { assert, test, newMockEvent, dataSourceMock } from "matchstick-as/assembly/index"
import { BigInt, DataSourceContext, Value } from "@graphprotocol/graph-ts"

import { handleApproveTokenDestinations } from "../../src/token-lock-wallet"
import { ApproveTokenDestinations } from "../../generated/templates/GraphTokenLockWallet/GraphTokenLockWallet"
import { TokenLockWallet } from "../../generated/schema"

test("Data source simple mocking example", () => {
    let addressString = "0xA16081F360e3847006dB660bae1c6d1b2e17eC2A"
    let address = Address.fromString(addressString)

    let wallet = new TokenLockWallet(address.toHexString())
    wallet.save()
    let context = new DataSourceContext()
    context.set("contextVal", Value.fromI32(325))
    dataSourceMock.setReturnValues(addressString, "rinkeby", context)
    let event = changetype<ApproveTokenDestinations>(newMockEvent())

    assert.assertTrue(!wallet.tokenDestinationsApproved)

    handleApproveTokenDestinations(event)

    wallet = TokenLockWallet.load(address.toHexString())!
    assert.assertTrue(wallet.tokenDestinationsApproved)
    assert.bigIntEquals(wallet.tokensReleased, BigInt.fromI32(325))

    dataSourceMock.resetValues()
})
```

Observa que dataSourceMock.resetValues() se llama al final. Eso es porque los valores se recuerdan cuando se cambian y necesitan ser restablecidos si quieres volver a los valores por defecto.

### Duraci√≥n del tiempo de ejecuci√≥n de la prueba en la salida del registro

La salida del registro incluye la duraci√≥n de la prueba. Aqu√≠ un ejemplo:

`Jul 09 14:54:42.420 INFO Program execution time: 10.06022ms`

## Comentarios

Si tienes alguna pregunta, comentario, petici√≥n de caracter√≠sticas o simplemente quieres ponerte en contacto, el mejor lugar ser√≠a The Graph Discord, donde tenemos un canal dedicado a Matchstick, llamado üî•| unit-testing.
