---
title: Manifest definition
---

The subgraph manifest `subgraph.yaml` defines the smart contracts your subgraph indexes, which events from these contracts to pay attention to, and how to map event data to entities that Graph Node stores and allows to query. The full specification for subgraph manifests can be found [here](https://github.com/graphprotocol/graph-node/blob/master/docs/subgraph-manifest.md).

For the example subgraph, `subgraph.yaml` is:

```yaml
specVersion: 0.0.4
description: Gravatar for Ethereum
repository: https://github.com/graphprotocol/example-subgraph
schema:
  file: ./schema.graphql
dataSources:
  - kind: ethereum/contract
    name: Gravity
    network: mainnet
    source:
      address: '0x2E645469f354BB4F5c8a05B3b30A929361cf77eC'
      abi: Gravity
      startBlock: 6175244
    mapping:
      kind: ethereum/events
      apiVersion: 0.0.6
      language: wasm/assemblyscript
      entities:
        - Gravatar
      abis:
        - name: Gravity
          file: ./abis/Gravity.json
      eventHandlers:
        - event: NewGravatar(uint256,address,string,string)
          handler: handleNewGravatar
        - event: UpdatedGravatar(uint256,address,string,string)
          handler: handleUpdatedGravatar
      callHandlers:
        - function: createGravatar(string,string)
          handler: handleCreateGravatar
      blockHandlers:
        - function: handleBlock
        - function: handleBlockWithCall
          filter:
            kind: call
      file: ./src/mapping.ts
```

The important entries to update for the manifest are:

- `description`: a human-readable description of what the subgraph is. This description is displayed by the Graph Explorer when the subgraph is deployed to the Hosted Service.

- `repository`: the URL of the repository where the subgraph manifest can be found. This is also displayed by the Graph Explorer.

- `features`: a list of all used [feature](#experimental-features) names.

- `schema`: a path to the `schema.graphql` file, which describes the [subgraph schema](/developing-subgraphs/schema).

- `dataSources.source`: the address of the smart contract the subgraph sources, and the abi of the smart contract to use. The address is optional; omitting it allows to index matching events from all contracts.

- `dataSources.source.startBlock`: the optional number of the block that the data source starts indexing from. In most cases we suggest using the block in which the contract was created.

- `dataSources.mapping.entities`: the entities that the data source writes to the store. The schema for each entity is defined in the the schema.graphql file.

- `dataSources.mapping.abis`: one or more named ABI files for the source contract as well as any other smart contracts that you interact with from within the mappings.

- `dataSources.mapping.eventHandlers`: lists the smart contract events this subgraph reacts to and the handlers in the mapping—./src/mapping.ts in the example—that transform these events into entities in the store.

- `dataSources.mapping.callHandlers`: lists the smart contract functions this subgraph reacts to and handlers in the mapping that transform the inputs and outputs to function calls into entities in the store.

- `dataSources.mapping.blockHandlers`: lists the blocks this subgraph reacts to and handlers in the mapping to run when a block is appended to the chain. Without a filter, the block handler will be run every block. An optional filter can be provided with the following kinds: call`. A`call` filter will run the handler if the block contains at least one call to the data source contract.

A single subgraph can index data from multiple smart contracts. Add an entry for each contract from which data needs to be indexed to the `dataSources` array.

The triggers for a data source within a block are ordered using the following process:

1. Event and call triggers are first ordered by transaction index within the block.
2. Event and call triggers with in the same transaction are ordered using a convention: event triggers first then call triggers, each type respecting the order they are defined in the manifest.
3. Block triggers are run after event and call triggers, in the order they are defined in the manifest.

These ordering rules are subject to change.

### Getting The ABIs

The ABI file(s) must match your contract(s). There are a few ways to obtain ABI files:

- If you are building your own project, you will likely have access to your most current ABIs.
- If you are building a subgraph for a public project, you can download that project to your computer and get the ABI by using [`truffle compile`](https://truffleframework.com/docs/truffle/overview) or using solc to compile.
- You can also find the ABI on [Etherscan](https://etherscan.io/), but this isn't always reliable, as the ABI that is uploaded there may be out of date. Make sure you have the right ABI, otherwise running your subgraph will fail.

## Data Source Templates

A common pattern in Ethereum smart contracts is the use of registry or factory
contracts, where one contract creates, manages or references an arbitrary number
of other contracts that each have their own state and events. The addresses of
these sub-contracts may or may not be known upfront and many of these contracts
may be created and/or added over time. This is why, in such cases, defining a
single data source or a fixed number of data sources is impossible and a more
dynamic approach is needed: _data source templates_.

### Data Source for the Main Contract

First, you define a regular data source for the main contract. The snippet below
shows a simplified example data source for the [Uniswap](https://uniswap.io)
exchange factory contract. Note the `NewExchange(address,address)` event
handler. This is emitted when a new exchange contract is created on chain by the
factory contract.

```yaml
dataSources:
  - kind: ethereum/contract
    name: Factory
    network: mainnet
    source:
      address: '0xc0a47dFe034B400B47bDaD5FecDa2621de6c4d95'
      abi: Factory
    mapping:
      kind: ethereum/events
      apiVersion: 0.0.6
      language: wasm/assemblyscript
      file: ./src/mappings/factory.ts
      entities:
        - Directory
      abis:
        - name: Factory
          file: ./abis/factory.json
      eventHandlers:
        - event: NewExchange(address,address)
          handler: handleNewExchange
```

### Data Source Templates for Dynamically Created Contracts

Then, you add _data source templates_ to the manifest. These are identical to
regular data sources, except that they lack a predefined contract address under
`source`. Typically, you would define one template for each type of sub-contract
managed or referenced by the parent contract.

```yaml
dataSources:
  - kind: ethereum/contract
    name: Factory
    # ... other source fields for the main contract ...
templates:
  - name: Exchange
    kind: ethereum/contract
    network: mainnet
    source:
      abi: Exchange
    mapping:
      kind: ethereum/events
      apiVersion: 0.0.6
      language: wasm/assemblyscript
      file: ./src/mappings/exchange.ts
      entities:
        - Exchange
      abis:
        - name: Exchange
          file: ./abis/exchange.json
      eventHandlers:
        - event: TokenPurchase(address,uint256,uint256)
          handler: handleTokenPurchase
        - event: EthPurchase(address,uint256,uint256)
          handler: handleEthPurchase
        - event: AddLiquidity(address,uint256,uint256)
          handler: handleAddLiquidity
        - event: RemoveLiquidity(address,uint256,uint256)
          handler: handleRemoveLiquidity
```

### Instantiating a Data Source Template

In the final step, you update your main contract mapping to create a dynamic
data source instance from one of the templates. In this example, you would
change the main contract mapping to import the `Exchange` template and call
the `Exchange.create(address)` method on it to start indexing the new
exchange contract.

```typescript
import { Exchange } from '../generated/templates'

export function handleNewExchange(event: NewExchange): void {
  // Start indexing the exchange; `event.params.exchange` is the
  // address of the new exchange contract
  Exchange.create(event.params.exchange)
}
```

> **Note:** A new data source will only process the calls and events for the
> block in which it was created and all following blocks, but will not process
> historical data, i.e., data that is contained in prior blocks.
>
> If prior blocks contain data relevant to the new data source, it is best to
> index that data by reading the current state of the contract and creating
> entities representing that state at the time the new data source is created.

### Data Source Context

Data source contexts allow passing extra configuration when instantiating a
template. In our example, let's say exchanges are associated with a particular
trading pair, which is included in the `NewExchange` event. That information
can be passed into the instantiated data source, like so:

```typescript
import { Exchange } from '../generated/templates'

export function handleNewExchange(event: NewExchange): void {
  let context = new DataSourceContext()
  context.setString('tradingPair', event.params.tradingPair)
  Exchange.createWithContext(event.params.exchange, context)
}
```

Inside a mapping of the `Exchange` template, the context can then be accessed:

```typescript
import { dataSource } from '@graphprotocol/graph-ts'

let context = dataSource.context()
let tradingPair = context.getString('tradingPair')
```

There are setters and getters like `setString` and `getString` for all value
types.

## Start Blocks

The `startBlock` is an optional setting that allows you to define from which
block in the chain the data source will start indexing. Setting the start block
allows the data source to skip potentially millions of blocks that are irrelevant.
Typically, a subgraph developer will set `startBlock` to the block in which
the smart contract of the data source was created.

```yaml
dataSources:
  - kind: ethereum/contract
    name: ExampleSource
    network: mainnet
    source:
      address: '0xc0a47dFe034B400B47bDaD5FecDa2621de6c4d95'
      abi: ExampleContract
      startBlock: 6627917
    mapping:
      kind: ethereum/events
      apiVersion: 0.0.6
      language: wasm/assemblyscript
      file: ./src/mappings/factory.ts
      entities:
        - User
      abis:
        - name: ExampleContract
          file: ./abis/ExampleContract.json
      eventHandlers:
        - event: NewEvent(address,address)
          handler: handleNewEvent
```

> **Note:** The contract creation block can be quickly looked up on
> Etherscan:
>
> 1.  Search for the contract by entering its address in the search bar.
> 2.  Click on the creation transaction hash in the `Contract Creator` section.
> 3.  Load the transaction details page where you'll find the start block
>     for that contract.

## Call Handlers

While events provide an effective way to collect relevant changes to the state
of a contract, many contracts avoid generating logs to optimize gas costs. In
these cases, a subgraph can subscribe to calls made to the data source contract.
This is achieved by defining call handlers referencing the function signature
and the mapping handler that will process calls to this function. To process
these calls, the mapping handler will receive an `ethereum.Call` as an argument
with the typed inputs to and outputs from the call. Calls made at any depth in a
transaction's call chain will trigger the mapping, allowing activity with the
data source contract through proxy contracts to be captured.

Call handlers will only trigger in one of two cases: when the function specified is called by an account other than the contract itself or when it is marked as external in Solidity and called as part of another function in the same contract.

> **Note:** Call handlers are not supported on Rinkeby, Goerli or Ganache. Call handlers currently
> depend on the Parity tracing API and these networks do not support it.

### Defining a Call Handler

To define a call handler in your manifest simply add a `callHandlers` array
under the data source you would like to subscribe to.

```yaml
dataSources:
  - kind: ethereum/contract
    name: Gravity
    network: mainnet
    source:
      address: '0x731a10897d267e19b34503ad902d0a29173ba4b1'
      abi: Gravity
    mapping:
      kind: ethereum/events
      apiVersion: 0.0.6
      language: wasm/assemblyscript
      entities:
        - Gravatar
        - Transaction
      abis:
        - name: Gravity
          file: ./abis/Gravity.json
      callHandlers:
        - function: createGravatar(string,string)
          handler: handleCreateGravatar
```

The `function` is the normalized function signature to filter calls by. The
`handler` property is the name of the function in your mapping you would like to
execute when the target function is called in the data source contract.

### Mapping Function

Each call handler takes a single parameter that has a type corresponding to the
name of the called function. In the example subgraph above, the mapping contains
a handler for when the `createGravatar` function is called and receives a
`CreateGravatarCall` parameter as an argument:

```typescript
import { CreateGravatarCall } from '../generated/Gravity/Gravity'
import { Transaction } from '../generated/schema'

export function handleCreateGravatar(call: CreateGravatarCall): void {
  let id = call.transaction.hash.toHex()
  let transaction = new Transaction(id)
  transaction.displayName = call.inputs._displayName
  transaction.imageUrl = call.inputs._imageUrl
  transaction.save()
}
```

The `handleCreateGravatar` function takes a new `CreateGravatarCall` which is a
subclass of `ethereum.Call`, provided by `@graphprotocol/graph-ts`, that includes
the typed inputs and outputs of the call. The `CreateGravatarCall` type is
generated for you when you run `graph codegen`.

## Block Handlers

In addition to subscribing to contract events or function calls, a subgraph may
want to update its data as new blocks are appended to the chain. To achieve this
a subgraph can run a function after every block or after blocks that match a
predefined filter.

### Supported Filters

```yaml
filter:
  kind: call
```

_The defined handler will be called once for every block which contains a call
to the contract (data source) the handler is defined under._

The absense of a filter for a block handler will ensure that the handler is
called every block. A data source can only contain one block handler for each
filter type.

```yaml
dataSources:
  - kind: ethereum/contract
    name: Gravity
    network: dev
    source:
      address: '0x731a10897d267e19b34503ad902d0a29173ba4b1'
      abi: Gravity
    mapping:
      kind: ethereum/events
      apiVersion: 0.0.6
      language: wasm/assemblyscript
      entities:
        - Gravatar
        - Transaction
      abis:
        - name: Gravity
          file: ./abis/Gravity.json
      blockHandlers:
        - handler: handleBlock
        - handler: handleBlockWithCallToContract
          filter:
            kind: call
```

### Mapping Function

The mapping function will receive an `ethereum.Block` as its only argument. Like
mapping functions for events, this function can access existing subgraph
entities in the store, call smart contracts and create or update entities.

```typescript
import { ethereum } from '@graphprotocol/graph-ts'

export function handleBlock(block: ethereum.Block): void {
  let id = block.hash.toHex()
  let entity = new Block(id)
  entity.save()
}
```

## Anonymous Events

If you need to process anonymous events in Solidity, that can be achieved by
providing the topic 0 of the event, as in the example:

```yaml
eventHandlers:
  - event: LogNote(bytes4,address,bytes32,bytes32,uint256,bytes)
    topic0: '0xbaa8529c00000000000000000000000000000000000000000000000000000000'
    handler: handleGive
```

An event will only be triggered when both the signature and topic 0 match. By
default, `topic0` is equal to the hash of the event signature.

## Experimental features

Starting from `specVersion` `0.0.4`, subgraph features must be explicitly declared in the `features` section at the top level of the
manifest file, using their `camelCase` name, as listed in the table below:

| Feature                                                   | Name                      |
| --------------------------------------------------------- | ------------------------- |
| [Non-fatal errors](#non-fatal-errors)                     | `nonFatalErrors`          |
| [Full-text Search](#defining-fulltext-search-fields)      | `fullTextSearch`          |
| [Grafting](#grafting-onto-existing-subgraphs)             | `grafting`                |
| [IPFS on Ethereum Contracts](#ipfs-on-ethereum-contracts) | `ipfsOnEthereumContracts` |

For instance, if a subgraph uses the **Full-Text Search** and the **Non-fatal Errors** features, the
`features` field in the manifest should be:

```yaml
specVersion: 0.0.4
description: Gravatar for Ethereum
features:
  - fullTextSearch
  - nonFatalErrors
dataSources: ...
```

Note that using a feature without declaring it will incur in a **validation error** during subgraph
deployment, but no errors will occur if a feature is declared but not used.

### IPFS on Ethereum Contracts

A common use case for combining IPFS with Ethereum is to store data on IPFS that
would be too expensive to maintain on chain, and reference the IPFS hash in
Ethereum contracts.

Given such IPFS hashes, subgraphs can read the corresponding files from IPFS
using `ipfs.cat` and `ipfs.map`. To do this reliably, however, it is required
that these files are pinned on the IPFS node that the Graph Node indexing the
subgraph connects to. In the case of the [hosted
service](https://thegraph.com/hosted-service), this is
[https://api.thegraph.com/ipfs/](https://api.thegraph.com/ipfs/).

> **Note:** The Graph Network does not yet support `ipfs.cat` and `ipfs.map`, and developers should not deploy subgraphs using that functionality to the network via the Studio.

In order to make this easy for subgraph developers, The Graph team wrote a tool
for transfering files from one IPFS node to another, called
[ipfs-sync](https://github.com/graphprotocol/ipfs-sync).

> **[Feature Management](#experimental-features):** `ipfsOnEthereumContracts` must be declared under
> `features` in the subgraph manifest.

### Non-fatal errors

Indexing errors on already synced subgraphs will, by default, cause the subgraph to fail and stop
syncing. Subgraphs can alternatively be configured to continue syncing in the presence of errors, by
ignoring the changes made by the handler which provoked the error. This gives subgraph authors time
to correct their subgraphs while queries continue to be served against the latest block, though the
results will possibly be inconsistent due to the bug that caused the error. Note that some errors
are still always fatal, to be non-fatal the error must be known to be deterministic.

> **Note:** The Graph Network does not yet support non-fatal errors, and developers should not deploy subgraphs using that functionality to the network via the Studio.

Enabling non-fatal errors requires setting the following feature flag on the subgraph manifest:

```yaml
specVersion: 0.0.4
description: Gravatar for Ethereum
features:
    - fullTextSearch
    ...
```

The query must also opt-in to querying data with potential inconsistencies through the
`subgraphError` argument. It is also recommended to query `_meta` to check if the subgraph has
skipped over errors, as in the example:

```graphql
foos(first: 100, subgraphError: allow) {
  id
}

_meta {
  hasIndexingErrors
}
```

If the subgraph encounters an error that query will return both the data and a graphql error with the
message `"indexing_error"`, as in this example response:

```graphql
"data": {
    "foos": [
        {
          "id": "fooId"
        }
    ],
    "_meta": {
        "hasIndexingErrors": true
    }
},
"errors": [
    {
        "message": "indexing_error"
    }
]
```

### Grafting onto Existing Subgraphs

When a subgraph is first deployed, it starts indexing events at the genesis block
of the corresponding chain (or at the `startBlock` defined with each data source)
In some circumstances, it is beneficial to reuse the data from an existing
subgraph and start indexing at a much later block. This mode of indexing is
called _Grafting_. Grafting is, for example, useful during development to get
past simple errors in the mappings quickly, or to temporarily get an existing
subgraph working again after it has failed.

> **Note:** Grafting requires that the Indexer has indexed the base subgraph. It is not recommended on The Graph Network at this time, and developers should not deploy subgraphs using that functionality to the network via the Studio.

A subgraph is grafted onto a base subgraph when the subgraph manifest in
`subgraph.yaml` contains a `graft` block at the toplevel:

```yaml
description: ...
graft:
  base: Qm... # Subgraph ID of base subgraph
  block: 7345624 # Block number
```

When a subgraph whose manifest contains a `graft` block is deployed, Graph Node
will copy the data of the `base` subgraph up to and including the given `block`
and then continue indexing the new subgraph from that block on. The base subgraph
must exist on the target Graph Node instance and must have indexed up to at least
the given block. Because of this restriction, grafting should only be used during
development or during an emergency to speed up producing an equivalent non-grafted
subgraph.

Because grafting copies rather than indexes base data it is much quicker in
getting the subgraph to the desired block than indexing from scratch, though
the initial data copy can still take several hours for very large subgraphs.
While the grafted subgraph is being initialized, the Graph Node will log
information about the entity types that have already been copied.

The grafted subgraph can use a GraphQL schema that is not identical to the one
of the base subgraph, but merely compatible with it. It has to be a valid
subgraph schema in its own right but may deviate from the base subgraph's
schema in the following ways:

- It adds or removes entity types
- It removes attributes from entity types
- It adds nullable attributes to entity types
- It turns non-nullable attributes into nullable attributes
- It adds values to enums
- It adds or removes interfaces
- It changes for which entity types an interface is implemented

> **[Feature Management](#experimental-features):** `grafting` must be declared under `features` in
> the subgraph manifest.
